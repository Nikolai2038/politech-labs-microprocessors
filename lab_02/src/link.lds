ENTRY(vector_base) /* Адрес точки входа для ELF образа */

/* Зоны памяти  */
MEMORY
{
	ram : ORIGIN = 0, LENGTH = 128M 	/* Память: адрес и размер */
}

ram_end = ORIGIN(ram) + LENGTH(ram);

/* Размещение секций */
SECTIONS
{
	. = 0;	/* счет адресов от 0  */

	.text . :	/* Имя выходной секции */
	{
		. = 0;
		*(.init_code)	/* Самой первой размещаем секцию .init_code => адрес=0 */
		*(.text)		/* Секция кода по умолчанию */
		*(.rodata)	/* Данные только для чтения для C */
		*(.rodata*)	/* Данные только для чтения для C */
		*(.glue_7)	/* Служебные коды ? ARM/THUMB C */
		*(.glue_7t)	/* Служебные коды ? ARM/THUMB C */
	} > ram       /* По какой зоне памяти размещать выходную секцию */

	. = ALIGN(4);	/* Выравнивание по границе слова */
	data_start = .;

	.data . :	/* Имя выходной секции */
	{
		. = 0;
		*(.data)		/* Секция инициализированных данных по умолчанию */
	} > ram

	. = ALIGN(4);
	_edata = .;	/* Конец инициализированной зоны (выровненный) */

	/* Далее мы автоматически вычислим адреса начала и конца зоны неинициализированных данных.
        Важно, чтобы они были выровнены на границу слова (4 байта), чтобы не было ошибок
        выравнивания при их обнулении кодом начальной загрузки */

	. = ALIGN(4);	/* Выравнивание по границе слова */
	_bss_start = .;	/* Глобальный символ начала зоны неинициализированных данных */
	.bss . :	/* Имя выходной секции */
	{
		. = 0;
		*(.bss)			/* Неинициализированные данные */
	} > ram

	. = ALIGN(4);
	_bss_end = . ;     /* Глобальный символ конца зоны неинициализированных данных */

}
	_end = .;		/* Глобальный символ: адрес конца зоны программы */

/* За символом _end программа может, например, разместить зону выделения динамической памяти */
